# Chapter 4: 산술식 작성

지금까지 덧셈 연산자 **+**를 사용한 샘플들을 보았습니다. 이 단원에서는 다른 arithmetric operator와 Java가 연산자 우선순위와 연관성을 다루는 방법에 대해 배웁니다.

## 84
덧셈, 뺄셈, 곱셈 및 나눗셈과 같은 기본 산술 계산을 위해 +, -, *, / 연산자를 사용하여 배치합니다:

[source, java]
----
6 + 3           // 더하기, 9로 평가
6 - 3           // 빼기, 3으로 평가
6 * 3           // 곱하기, 18로 평가
6 / 3           // 나누기, 2로 평가
6 + y           // 더하기, 6에 y의 값 더하기
x - 3           // 빼기, x의 값에서 3 빼기
x * y           // 곱하기, x의 값에 y의 값 곱하기
x / y           // 나누기, x의 값에서 y의 값 나누기
----

## 85

정수 분모가 정수 분자로 나누어 떨어지지 않을 때, 나눗셈 연산자는 소수점 이하를 버린 다른 정수를 생성합니다. **나머지 연산자 %**는 정수의 나머지를 생성합니다.

[source, java]
----
5 / 3           // 나누기, 1로 평가
-5 / 3          // 나누기, -1로 평가
5 % 3           // 나누기, 나머지 2로 평가
-5 % 3          // 나누기, 나머지 -2로 평가
----

물론 Java가 부동 소수점 숫자를 나눌 때 부동 소수점 결과를 생성합니다.

[source, java]
----
5.0 / 3.0       // 나누기, 1.66667으로 평가
----

## 86

산술식은 하나의 연산자를 포함할 수 있지만, 연산자가 없거나 여러 개일 수도 있습니다.

[source, java]
----
6               // 리터럴 식
x               // 변수 식
6 + 3 + 2       // 11을 생성합니다.
6 - 3 - 2       // 1을 생성합니다.
6 * 3 * 2       // 36을 생성합니다.
6 / 3 / 2       // 1을 생성합니다.
----

## 87

Java의 연산자에 대한 피연산자를 결정하는 규칙은 표준적인 관행을 따릅니다. 예를 들어, 곱셈이 덧셈보다 **우선**순위가 높기 때문에 Java 컴파일러는 **6 + 3 * 2**를 (6 + 3) * 2가 아닌 **6 + (3 * 2)**와 동일하게 처리합니다.

[source, java]
----
6 + 3 * 2       // 18이 아닌 12로 평가됩니다.
----

## 88

곱셈과 나눗셈과 같은 우선순위가 같은 두 연산자가 있는 식은 다음 예에서와 같이 처리됩니다.

[source, java]
----
6 / 3 * 2       // (6 / 3) * 2 = 4와 동일합니다.
                // 6 / (3 * 2) = 1이 아닙니다.
6 * 3 / 2       // (6 * 3) / 2 = 9와 동일합니다.
                // 6 * (3 / 2) = 6이 아닙니다.
----

따라서 Java에서의 곱셈 및 나눗셈 연산자는 왼쪽에서 오른쪽으로 **결합**됩니다. 대부분의 연산자는 왼쪽에서 오른쪽으로 결합하지만, 세그먼트 95 및 부록 A에 제공된 표에서와 같이 일부 연산자는 그렇지 않습니다.

## 89

물론 Java 컴파일러의 전체 식 해석이 원하는 해석이 아닐 때 언제든지 하위 식 주위에 괄호를 사용할 수 있습니다.

[source, java]
----
6 + 3 * 2       // 값은 18이 아닌 12입니다.
(6 + 3) * 2     // 값은 12가 아닌 18입니다.
----

의도를 명확하게 하기 위해 괄호를 사용할 수도 있습니다. 예를 들어 다음과 같이 괄호를 사용하지 않아도 됩니다. 하지만 많은 프로그래머들이 괄호를 삽입하여 식의 의미를 명확하게합니다.

[source, java]
--
6 + 3 * 2       // 값은 명확히 12입니다.
6 + (3 * 2)     // 값은 더욱 명확하게 12입니다.
--

이러한 괄호를 삽입하는 것은 특히 큰 식을 처리 할 때 좋은 아이디어입니다.

90: 본문
대부분의 연산자는 이항 연산자입니다. 즉, 두 개의 피연산자가 있습니다. Java에서 두 개의 피연산자는 연산자의 바로 왼쪽과 오른쪽에서 찾을 수 있습니다. 부정 연산자 **-**와 양의 단항 연산자 **+**와 같은 일부 연산자는 연산자 바로 오른쪽에 하나의 피연산자를 갖습니다. 이러한 연산자는 단항 연산자입니다.

- 및 **+**이 단항 또는 이항 연산자인지 여부는 연산자 바로 왼쪽에 리터럴, 변수 또는 하위 식이 있는지 여부를 확인하여 결정할 수 있습니다. 바로 왼쪽에 리터럴, 변수 또는 하위식이 있으면 **-**는 뺄셈을 나타내고 **+**는 덧셈을 나타내고 그렇지 않으면 **-**는 부정을 나타내고 **+**는 전혀 없는 것처럼 처리됩니다.

91: 본문
부정 연산자 **-**의 우선순위는 +, -, *, 또는 **/**보다 높습니다.

- 6 * 3 / 2     // ((- 6) * 3) / 2 = -9와 동일합니다
-(-(-6 * 3)) / 2 // - 뒤에는 숫자 뿐만 아나라 하위식이 올수도 있습니다.
92: 본문
데이터 유형이 혼합된 값을 포함하는 산술식을 혼합식이라고 합니다. Java가 혼합식을 계산할 때는 먼저 주어진 값으로 동일 유형의 값 집합을 생성한 다음 지정된 산술을 수행합니다.

따라서 부동 소수점 숫자와 정수를 곱하는 혼합식이 주어지면 Java는 먼저 정수에서 부동 소수점 숫자를 생성한 다음 곱셈을 수행합니다.

93: 본문
Java가 자동 변환에 의존하는 대신 값을 명시적으로 하나의 유형에서 다른 유형으로 변환하려면, 표현식을 유형변환(캐스트)해야 합니다. 유형변환하려면 괄호 안에 원하는 유형의 이름을 표시하면 됩니다.

예를 들어, i가 int이고 d가 double이면 다음과 같이 i를 double로 캐스트하고 d를 int로 캐스트할 수 있습니다.

(double) i         // double 표현식
(int) d            // int 표현식
i와 d 변수의 원래 유형은 변경되지 않습니다. i는 여전히 int 변수이고 d는 여전히 double 변수입니다.

94: 본문
모든 연산자와 마찬가지로 할당 연산자 **=**는 값이 생성됩니다. 관례상 할당된 값과 동일한 값을 생성합니다. 따라서 식 y = 5의 값은 5입니다.

할당 표현식은 값이 생성되기 때문에 더 큰 표현식 내부에 중첩된 하위 표현식으로 나타날 수 있습니다.

다음 할당 표현식에서는 y에 값을 할당하는 할당 표현식 y = 5이 x에 값을 할당하는 더 큰 할당 표현식 내부에 나타납니다.

x = (y = 5)
95: 본문
다른 모든 이항 연산자와는 달리 할당 연산자 **=**는 오른쪽에서 왼쪽으로 결합됩니다. 따라서 식 x = y = 5는 식 **x = (y = 5)**와 동일합니다.

다행히도 x = y = 5는 (x = y) = 5와 같지 않습니다. 할당 문의 값은 변수 이름이 아니기 때문입니다. 그러므로 할당 연산자가 왼쪽에서 오른쪽으로 결합한다면 x = y = 5도 의미가 없어집니다.

96: 본문
지금까지 배운 연산자의 우선순위와 결합성은 나중에 배우게 될 다른 연산자와 함께 AppendixA에 나열되어 있습니다.

97: 정리
Java는 부정, 단항 더하기, 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 및 할당 연산자를 제공합니다.
Java는 일반적인 우선순위와 결합성 규칙을 따릅니다.
할당 연산자 **=**는 산술 연산자보다 우선순위가 낮습니다.
일반적인 우선순위와 결합성 규칙이 원하는 결과를 생성하지 않으면 괄호를 사용하여 하위 표현식을 만드세요.